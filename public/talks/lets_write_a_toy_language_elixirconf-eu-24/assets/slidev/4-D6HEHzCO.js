import{o as n,c as e,k as r,q as s,s as o,A as a,e as t}from"../modules/vue-BXmsG0jI.js";import{I as d}from"./default-BB9pI-bH.js";import{b as u,a8 as l}from"../index-JOTi8wQD.js";import{p as i,u as c,f as p}from"./context-DdVlVafZ.js";import"../modules/shiki-D8IwEf5w.js";const m=t("h2",null,"From zero to Ovo : implementation steps",-1),f=t("table",{class:"mt-2 table striped"},[t("thead",null,[t("tr",{class:"bg-gray-100"},[t("th",{class:"font-bold"},"Step"),t("th",{class:"font-bold"},"Input"),t("th",{class:"font-bold"},"Output"),t("th",{class:"font-bold"},"Method used")])]),t("tbody",null,[t("tr",null,[t("td",null,"Tokenizing"),t("td",null,"program text"),t("td",null,"a list of tokens"),t("td",null,"character walking")]),t("tr",{class:"bg-gray-100"},[t("td",null,"Parsing"),t("td",null,"a list of tokens"),t("td",null,"an abstract syntax tree"),t("td",null,"parser combinators")]),t("tr",null,[t("td",null,"Printing"),t("td",null,"an abstract syntax tree"),t("td",null,"normalized program text"),t("td",null,"tree-walking")]),t("tr",{class:"bg-gray-100"},[t("td",null,"Rewrites and transforms"),t("td",null,"an abstract syntax tree"),t("td",null,"an abstract syntax tree"),t("td",null,"pattern matching")]),t("tr",null,[t("td",null,"Evaluation"),t("td",null,"an abstract syntax tree"),t("td",null,"a single node"),t("td",null,"tree-walking interpreter")])])],-1),_={__name:"4",setup(b){return i(l),c(),(g,h)=>(n(),e(d,s(o(a(p)(a(l),3))),{default:r(()=>[m,f]),_:1},16))}},P=u(_,[["__file","/@slidev/slides/4.md"]]);export{P as default};
