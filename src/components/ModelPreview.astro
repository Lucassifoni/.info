---
---

<style is:global>
    .model-preview-overlay {
        position: fixed;
        inset: 16px;
        z-index: 1000;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        flex-direction: column;
        border-radius: 6px;
    }

    .model-preview-overlay .toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.5em 1em;
        color: #ccc;
        font-size: 0.85em;
        font-family: monospace;
    }

    .model-preview-overlay .close-btn {
        background: none;
        border: 1px solid #666;
        color: #ccc;
        padding: 0.3em 0.8em;
        cursor: pointer;
        border-radius: 3px;
        font-size: 0.85em;
    }

    .model-preview-overlay .close-btn:hover {
        background: #333;
    }

    .model-preview-overlay .viewer-container {
        flex: 1;
        position: relative;
        overflow: hidden;
    }

    .model-preview-overlay .viewer-container canvas {
        width: 100% !important;
        height: 100% !important;
    }

    .model-preview-overlay .status {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #999;
        font-size: 0.9em;
        pointer-events: none;
    }

    button.preview-btn {
        background: none;
        border: 1px solid #ccc;
        color: #555;
        padding: 0.15em 0.5em;
        cursor: pointer;
        border-radius: 3px;
        font-size: 0.8em;
        margin-left: 0.5em;
    }

    button.preview-btn:hover {
        background: #eee;
        border-color: #999;
    }
</style>

<script>
    import * as THREE from "three";
    import { STLLoader } from "three/addons/loaders/STLLoader.js";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    let occtPromise: Promise<any> | null = null;

    function getOcct() {
        if (!occtPromise) {
            occtPromise = import("occt-import-js").then((mod) =>
                mod.default({ locateFile: () => "/occt-import-js.wasm" }),
            );
        }
        return occtPromise;
    }

    function setupScene(container: HTMLElement) {
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x1a1a1a);
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 10000);

        scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.4));
        const key = new THREE.DirectionalLight(0xffffff, 1.0);
        key.position.set(2, 3, 4);
        scene.add(key);
        const fill = new THREE.DirectionalLight(0xffffff, 0.5);
        fill.position.set(-3, 1, -2);
        scene.add(fill);
        const rim = new THREE.DirectionalLight(0xffffff, 0.3);
        rim.position.set(0, -2, -3);
        scene.add(rim);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        const resize = () => {
            const w = container.clientWidth;
            const h = container.clientHeight;
            renderer.setSize(w, h);
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
        };
        resize();
        const ro = new ResizeObserver(resize);
        ro.observe(container);

        let running = true;
        const animate = () => {
            if (!running) return;
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        };
        animate();

        return {
            scene,
            camera,
            controls,
            dispose: () => {
                running = false;
                ro.disconnect();
                controls.dispose();
                renderer.dispose();
            },
        };
    }

    function frameBounds(
        object: THREE.Object3D,
        camera: THREE.PerspectiveCamera,
        controls: OrbitControls,
    ) {
        const box = new THREE.Box3().setFromObject(object);
        const center = box.getCenter(new THREE.Vector3());
        object.position.sub(center);

        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        camera.position.set(maxDim, maxDim * 0.8, maxDim * 1.5);
        camera.lookAt(0, 0, 0);
        controls.target.set(0, 0, 0);
        controls.update();
    }

    async function loadStl(src: string, scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls) {
        return new Promise<void>((resolve, reject) => {
            new STLLoader().load(
                src,
                (geometry) => {
                    geometry.computeBoundingBox();
                    const material = new THREE.MeshPhongMaterial({
                        color: 0x6688aa,
                        specular: 0x222222,
                        shininess: 40,
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    scene.add(mesh);
                    frameBounds(mesh, camera, controls);
                    resolve();
                },
                undefined,
                reject,
            );
        });
    }

    async function loadStep(src: string, scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls) {
        const [occt, response] = await Promise.all([getOcct(), fetch(src)]);
        const buffer = new Uint8Array(await response.arrayBuffer());
        const result = occt.ReadStepFile(buffer, null);

        const group = new THREE.Group();
        for (const mesh of result.meshes) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(mesh.attributes.position.array);
            geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
            if (mesh.attributes.normal) {
                const normals = new Float32Array(mesh.attributes.normal.array);
                geometry.setAttribute("normal", new THREE.BufferAttribute(normals, 3));
            }
            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(mesh.index.array), 1));

            let color = 0x6688aa;
            if (mesh.color) {
                color = new THREE.Color(mesh.color[0], mesh.color[1], mesh.color[2]).getHex();
            }
            const material = new THREE.MeshPhongMaterial({ color, specular: 0x222222, shininess: 40 });
            group.add(new THREE.Mesh(geometry, material));
        }

        scene.add(group);
        frameBounds(group, camera, controls);
    }

    function openPreview(src: string, ext: string, fileName: string) {
        const overlay = document.createElement("div");
        overlay.className = "model-preview-overlay";

        const toolbar = document.createElement("div");
        toolbar.className = "toolbar";
        const label = document.createElement("span");
        label.textContent = fileName;
        const closeBtn = document.createElement("button");
        closeBtn.className = "close-btn";
        closeBtn.textContent = "Close (Esc)";
        toolbar.appendChild(label);
        toolbar.appendChild(closeBtn);

        const viewerContainer = document.createElement("div");
        viewerContainer.className = "viewer-container";

        const status = document.createElement("div");
        status.className = "status";
        status.textContent = ext === "step" ? "Loading STEP (this may take a moment)\u2026" : "Loading\u2026";
        viewerContainer.appendChild(status);

        overlay.appendChild(toolbar);
        overlay.appendChild(viewerContainer);
        document.body.appendChild(overlay);

        const { scene, camera, controls, dispose } = setupScene(viewerContainer);

        const close = () => {
            dispose();
            overlay.remove();
            document.removeEventListener("keydown", onKey);
        };
        const onKey = (e: KeyboardEvent) => {
            if (e.key === "Escape") close();
        };
        closeBtn.addEventListener("click", close);
        document.addEventListener("keydown", onKey);

        const loader = ext === "step" ? loadStep : loadStl;
        loader(src, scene, camera, controls)
            .then(() => status.remove())
            .catch((err) => {
                status.textContent = `Failed to load ${ext.toUpperCase()} file`;
                console.error("ModelPreview:", err);
            });
    }

    document.addEventListener("click", (e) => {
        const btn = (e.target as HTMLElement).closest<HTMLButtonElement>("button.preview-btn");
        if (!btn) return;
        const src = btn.dataset.src!;
        const ext = btn.dataset.ext!;
        const fileName = btn.dataset.filename!;
        openPreview(src, ext, fileName);
    });
</script>
